% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TSCC.R
\name{TSCC}
\alias{TSCC}
\title{Cooperative coevolution with two stage grouping.}
\usage{
TSCC(
  contextVector = NULL,
  nVar,
  fun,
  ...,
  first_grouping = NULL,
  variable_importance = NULL,
  budget = 3e+06,
  lbound = rep(0, nVar),
  ubound = rep(1, nVar),
  nLevel = 4,
  evalInterval = 1e+05,
  SA_method = c("morris_mu", "morris_k", "rf", "sobol"),
  keepCovariance = F,
  scale = T
)
}
\arguments{
\item{fun}{The objective function object to be solved}

\item{...}{Further arguments passed to \code{fun}.}

\item{first_grouping}{Vector of list. Each list should contain the group members.
If not supplied, the grouping will use the chosen SA_method.
This group would be subject to the method: \code{DG2}.}

\item{variable_importance}{Used if first_grouping is supplied. If NULL, all variables will have same importance.}

\item{lbound}{Lower bound of the decision vector. A vector with finite values.}

\item{ubound}{upper bound of the decision vector. A vector with finite values.}

\item{nLevel}{Number of level for Morris method. Used if group is not supplied}

\item{evalInterval}{Interval for data logging.}

\item{SA_method}{sensitivity analysis method. It is recommended to use the morris method: \code{'morris_mu'}.
Although other SA_method should not cause an error, the package is mostly tested with \code{'morris_mu'}.}

\item{keepCovariance}{Set whether the covariance matrix is persistent througout the run.
If false, the Cov matrix will reset to identity matrix in each cycle.}

\item{scale}{If \code{TRUE}, the input vector will be scaled to [0,1] for processing,
otherwise the it will be in the range \code{[lbound,ubound]}}

\item{population}{Initial population}
}
\description{
Two stage cooperative coevolution with CMA-ES
The CMA-ES is used as solver and its
step size is set based on  \code{lbound} and  \code{ubound}.
This means \code{lbound} and  \code{ubound}
must be finite.
}
\examples{
optimum <- rep(13,1000)
func <- f1cec
ctrl <- list(lbound=rep(-100,1000),ubound=rep(100,1000),delta=rep(20,1000))
TSCC(nVar = 1000,fun=func,lbound=rep(-100,1000),ubound=rep(100,1000),o=optimum)
}
